From 7f178663ebffc82c9f8a5a1b6bf2da0c263a30ed Mon Sep 17 00:00:00 2001
From: Daniel Bevenius <daniel.bevenius@gmail.com>
Date: Wed, 2 Dec 2020 18:21:41 +0100
Subject: [PATCH] src: use unique_ptr for WriteWrap
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit attempts to avoid a use-after-free error by using unqiue_ptr
and passing a reference to it.

CVE-ID: CVE-2020-8265
Fixes: https://github.com/nodejs-private/node-private/issues/227
PR-URL: https://github.com/nodejs-private/node-private/pull/238
Reviewed-By: Michael Dawson <midawson@redhat.com>
Reviewed-By: Tobias Nie√üen <tniessen@tnie.de>
Reviewed-By: Richard Lau <rlau@redhat.com>
Reference: https://github.com/nodejs/node/commit/7f178663ebffc82c9f8a5a1b6bf2da0c263a30ed
---
 src/js_stream.cc      |  4 ++--
 src/js_stream.h       |  2 +-
 src/node_file.h       |  2 +-
 src/node_http2.cc     |  4 ++--
 src/node_http2.h      |  2 +-
 src/stream_base-inl.h |  8 ++++----
 src/stream_base.h     |  9 +++++----
 src/stream_wrap.cc    |  4 ++--
 src/stream_wrap.h     |  2 +-
 src/tls_wrap.cc       | 13 +++++++------
 src/tls_wrap.h        |  4 ++--
 11 files changed, 28 insertions(+), 26 deletions(-)

diff --git a/src/js_stream.cc b/src/js_stream.cc
index 4769a9c..f70b26b 100644
--- a/src/js_stream.cc
+++ b/src/js_stream.cc
@@ -105,7 +105,7 @@ int JSStream::DoShutdown(ShutdownWrap* req_wrap) {
 }
 
 
-int JSStream::DoWrite(WriteWrap* w,
+int JSStream::DoWrite(std::unique_ptr<WriteWrap>& w,
                       uv_buf_t* bufs,
                       size_t count,
                       uv_stream_t* send_handle) {
@@ -122,7 +122,7 @@ int JSStream::DoWrite(WriteWrap* w,
   }
 
   Local<Value> argv[] = {
-    w->object(),
+    w.get()->object(),
     bufs_arr
   };
 
diff --git a/src/js_stream.h b/src/js_stream.h
index 05fb688..9e4b5a8 100644
--- a/src/js_stream.h
+++ b/src/js_stream.h
@@ -22,7 +22,7 @@ class JSStream : public AsyncWrap, public StreamBase {
   int ReadStop() override;
 
   int DoShutdown(ShutdownWrap* req_wrap) override;
-  int DoWrite(WriteWrap* w,
+  int DoWrite(std::unique_ptr<WriteWrap>& w,
               uv_buf_t* bufs,
               size_t count,
               uv_stream_t* send_handle) override;
diff --git a/src/node_file.h b/src/node_file.h
index 73202d9..fc5475e 100644
--- a/src/node_file.h
+++ b/src/node_file.h
@@ -246,7 +246,7 @@ class FileHandle : public AsyncWrap, public StreamBase {
   ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override;
   int DoShutdown(ShutdownWrap* req_wrap) override;
 
-  int DoWrite(WriteWrap* w,
+  int DoWrite(std::unique_ptr<WriteWrap>& w,
               uv_buf_t* bufs,
               size_t count,
               uv_stream_t* send_handle) override {
diff --git a/src/node_http2.cc b/src/node_http2.cc
index 8841601..5ce2af0 100644
--- a/src/node_http2.cc
+++ b/src/node_http2.cc
@@ -2063,7 +2063,7 @@ int Http2Stream::ReadStop() {
 // chunks of data have been flushed to the underlying nghttp2_session.
 // Note that this does *not* mean that the data has been flushed
 // to the socket yet.
-int Http2Stream::DoWrite(WriteWrap* req_wrap,
+int Http2Stream::DoWrite(std::unique_ptr<WriteWrap>& req_wrap,
                          uv_buf_t* bufs,
                          size_t nbufs,
                          uv_stream_t* send_handle) {
@@ -2078,7 +2078,7 @@ int Http2Stream::DoWrite(WriteWrap* req_wrap,
     // Store the req_wrap on the last write info in the queue, so that it is
     // only marked as finished once all buffers associated with it are finished.
     queue_.emplace(nghttp2_stream_write {
-      i == nbufs - 1 ? req_wrap : nullptr,
+      i == nbufs - 1 ? req_wrap.get() : nullptr,
       bufs[i]
     });
     IncrementAvailableOutboundLength(bufs[i].len);
diff --git a/src/node_http2.h b/src/node_http2.h
index d7f8d9a..a327697 100644
--- a/src/node_http2.h
+++ b/src/node_http2.h
@@ -566,7 +566,7 @@ class Http2Stream : public AsyncWrap,
 
   AsyncWrap* GetAsyncWrap() override { return this; }
 
-  int DoWrite(WriteWrap* w, uv_buf_t* bufs, size_t count,
+  int DoWrite(std::unique_ptr<WriteWrap>& w, uv_buf_t* bufs, size_t count,
               uv_stream_t* send_handle) override;
 
   void MemoryInfo(MemoryTracker* tracker) const override {
diff --git a/src/stream_base-inl.h b/src/stream_base-inl.h
index 027b938..dca02ac 100644
--- a/src/stream_base-inl.h
+++ b/src/stream_base-inl.h
@@ -216,14 +216,14 @@ inline StreamWriteResult StreamBase::Write(
   }
 
   AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());
-  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);
+  std::unique_ptr<WriteWrap> req_wrap{CreateWriteWrap(req_wrap_obj)};
 
   err = DoWrite(req_wrap, bufs, count, send_handle);
   bool async = err == 0;
 
-  if (!async) {
+  if (!async && req_wrap != nullptr) {
     req_wrap->Dispose();
-    req_wrap = nullptr;
+    req_wrap.release();
   }
 
   const char* msg = Error();
@@ -232,7 +232,7 @@ inline StreamWriteResult StreamBase::Write(
     ClearError();
   }
 
-  return StreamWriteResult { async, err, req_wrap, total_bytes };
+  return StreamWriteResult { async, err, req_wrap.release(), total_bytes };
 }
 
 template <typename OtherBase>
diff --git a/src/stream_base.h b/src/stream_base.h
index 05c2a96..c8f8a0c 100644
--- a/src/stream_base.h
+++ b/src/stream_base.h
@@ -211,10 +211,11 @@ class StreamResource {
   // `*bufs` and `*count` accordingly. This is a no-op by default.
   virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);
   // Perform a write of data, and call req_wrap->Done() when finished.
-  virtual int DoWrite(WriteWrap* w,
-                      uv_buf_t* bufs,
-                      size_t count,
-                      uv_stream_t* send_handle) = 0;
+  virtual int DoWrite(
+      /* NOLINT (runtime/references) */ std::unique_ptr<WriteWrap>& w,
+      uv_buf_t* bufs,
+      size_t count,
+      uv_stream_t* send_handle) = 0;
 
   // Returns true if the stream supports the `OnStreamWantsWrite()` interface.
   virtual bool HasWantsWrite() const { return false; }
diff --git a/src/stream_wrap.cc b/src/stream_wrap.cc
index 60a1754..17cf861 100644
--- a/src/stream_wrap.cc
+++ b/src/stream_wrap.cc
@@ -330,11 +330,11 @@ int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) {
 }
 
 
-int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,
+int LibuvStreamWrap::DoWrite(std::unique_ptr<WriteWrap>& req_wrap,
                              uv_buf_t* bufs,
                              size_t count,
                              uv_stream_t* send_handle) {
-  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
+  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap.get());
   int r;
   if (send_handle == nullptr) {
     r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);
diff --git a/src/stream_wrap.h b/src/stream_wrap.h
index 487a40b..0d08683 100644
--- a/src/stream_wrap.h
+++ b/src/stream_wrap.h
@@ -51,7 +51,7 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {
   // Resource implementation
   int DoShutdown(ShutdownWrap* req_wrap) override;
   int DoTryWrite(uv_buf_t** bufs, size_t* count) override;
-  int DoWrite(WriteWrap* w,
+  int DoWrite(std::unique_ptr<WriteWrap>& w,
               uv_buf_t* bufs,
               size_t count,
               uv_stream_t* send_handle) override;
diff --git a/src/tls_wrap.cc b/src/tls_wrap.cc
index eb40d85..eb85332 100644
--- a/src/tls_wrap.cc
+++ b/src/tls_wrap.cc
@@ -93,8 +93,7 @@ bool TLSWrap::InvokeQueued(int status, const char* error_str) {
     return false;
 
   if (current_write_ != nullptr) {
-    WriteWrap* w = current_write_;
-    current_write_ = nullptr;
+    WriteWrap* w = current_write_.release();
     w->Done(status, error_str);
   }
 
@@ -551,7 +550,7 @@ void TLSWrap::ClearError() {
 }
 
 
-int TLSWrap::DoWrite(WriteWrap* w,
+int TLSWrap::DoWrite(std::unique_ptr<WriteWrap>& w,
                      uv_buf_t* bufs,
                      size_t count,
                      uv_stream_t* send_handle) {
@@ -578,7 +577,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
     // the callback should not be invoked immediately
     if (BIO_pending(enc_out_) == 0) {
       CHECK_NULL(current_empty_write_);
-      current_empty_write_ = w;
+      current_empty_write_ = w.get();
       StreamWriteResult res =
           underlying_stream()->Write(bufs, count, send_handle);
       if (!res.async) {
@@ -593,7 +592,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
 
   // Store the current write wrap
   CHECK_NULL(current_write_);
-  current_write_ = w;
+  current_write_ = std::move(w);
 
   // Write queued data
   if (empty) {
@@ -615,7 +614,7 @@ int TLSWrap::DoWrite(WriteWrap* w,
     int err;
     Local<Value> arg = GetSSLError(written, &err, &error_);
     if (!arg.IsEmpty()) {
-      current_write_ = nullptr;
+      current_write_.release();
       return UV_EPROTO;
     }
 
@@ -627,6 +626,8 @@ int TLSWrap::DoWrite(WriteWrap* w,
   // Try writing data immediately
   EncOut();
 
+  w.reset(current_write_.get());
+
   return 0;
 }
 
diff --git a/src/tls_wrap.h b/src/tls_wrap.h
index aea8568..eb6b153 100644
--- a/src/tls_wrap.h
+++ b/src/tls_wrap.h
@@ -67,7 +67,7 @@ class TLSWrap : public AsyncWrap,
   ShutdownWrap* CreateShutdownWrap(
       v8::Local<v8::Object> req_wrap_object) override;
   int DoShutdown(ShutdownWrap* req_wrap) override;
-  int DoWrite(WriteWrap* w,
+  int DoWrite(std::unique_ptr<WriteWrap>& w,
               uv_buf_t* bufs,
               size_t count,
               uv_stream_t* send_handle) override;
@@ -149,7 +149,7 @@ class TLSWrap : public AsyncWrap,
   BIO* enc_out_ = nullptr;
   std::vector<uv_buf_t> pending_cleartext_input_;
   size_t write_size_;
-  WriteWrap* current_write_ = nullptr;
+  std::unique_ptr<WriteWrap> current_write_ = nullptr;
   WriteWrap* current_empty_write_ = nullptr;
   bool write_callback_scheduled_ = false;
   bool started_;
-- 
2.23.0

